name: CI JAVA
on:
  workflow_call:
    secrets:
      SONAR_TOKEN:
        description: 'Token de SonarCloud para el análisis'
        required: true
      SNYK_TOKEN:
        description: 'Token de Snyk para el análisis'
        required: true
    inputs:
      workflow:
        type: string
        required: true
      releaseId:
        type: string
        required: false
        default: ""
      projectId:
        type: string
        required: false
        default: ""
      region:
        type: string
        required: false
        default: "DIGITAL"
      csild:
        type: string
        required: false
        default: ""

      # Bloques anidados como JSON string
      sourceCode_json:
        type: string
        required: false
        default: |
          {"projectStream":"master","projectModule":"","repositoryInstance":"Github"}
      build_json:
        type: string
        required: false
        default: |
          {"dependencyResolutionRepo":"artifactory","printVerboseLog":false,"deployLibraries":false,"pomFileLocation":".","packageIncludes":"","jenkinsAdditionalFolder":"content","svnProfiles":"","tibcoBW":{"stpVersion":""},"deployToPkgArchive":true}
      staticCodeAnalysis_json:
        type: string
        required: false
        default: |
          {"blackDuck":{"RELEASENAME":"","BD_ARCHER_COMPONENT":"","SCAN_WF":"","BD_SOURCE_SYSTEM":""},
           "checkmarx":{"CHECKMARX_CONFIG_CMPNAME":"","CHECKMARX_ENV":"","SCAN_WF":"","CHECKMARX_CX_TEAMNAME":"","CHECKMARX_ARCHER_BASE_CMPNAME":"","CHECKMARX_TYPE_WF_SCAN":"","RELEASENAME":""},
           "sonarQube":{"sonarExcludes":"","sonarLanguage":""},
           "appscan":{"archerRecord":""}}
      threshold_json:
        type: string
        required: false
        default: |
          {"unitTestSuccessDensity":0,"securityRating":0,"techDebtRatio":0,"reliabilityRating":0,"unitTestCoverage":0}
      deploy_json:
        type: string
        required: false
        default: |
          {"NA":{"rlmExecute":false,"rlmEnvironment":"","rlmParams":"","rlmUIParams":"","rlmTemplate":""},
           "SWSDEVTEST":{"rlmExecute":true,"rlmEnvironment":"","rlmParams":"","rlmUIParams":"","rlmTemplate":""}}

      postBuildDeployEnv:
        type: string
        required: false
        default: ""

jobs:
  pipeline-ci-java:
    runs-on: ubuntu-latest
    # Permisos necesarios para firmar (ej. con Sigstore) y
    # publicar en el registro de GitHub (GHCR)
    permissions:
      contents: read
      packages: write # Para 'docker push' a GHCR
      id-token: write # Para autenticación 'keyless' de Sigstore/cosign
      security-events: write # Requerido para subir resultados SARIF
    env:
      # escala simple
      WORKFLOW: ${{ inputs.workflow }}
      RELEASE_ID: ${{ inputs.releaseId }}
      PROJECT_ID: ${{ inputs.projectId }}
      REGION: ${{ inputs.region }}
      CSILD: ${{ inputs.csild }}

      # parseo JSON a nivel de env cuando conviene (campos más usados)
      SOURCE_PROJECT_STREAM: ${{ fromJSON(inputs.sourceCode_json).projectStream }}
      SOURCE_PROJECT_MODULE: ${{ fromJSON(inputs.sourceCode_json).projectModule }}
      SOURCE_REPO_INSTANCE: ${{ fromJSON(inputs.sourceCode_json).repositoryInstance }}

      BUILD_VERBOSE: ${{ fromJSON(inputs.build_json).printVerboseLog }}
      BUILD_DEPLOY_LIBS: ${{ fromJSON(inputs.build_json).deployLibraries }}
      BUILD_POM: ${{ fromJSON(inputs.build_json).pomFileLocation }}
      BUILD_DEPLOY_TO_ARCHIVE: ${{ fromJSON(inputs.build_json).deployToPkgArchive }}

      # thresholds
      THRESH_UT_SUCCESS: ${{ fromJSON(inputs.threshold_json).unitTestSuccessDensity }}
      THRESH_SEC: ${{ fromJSON(inputs.threshold_json).securityRating }}
      THRESH_TD: ${{ fromJSON(inputs.threshold_json).techDebtRatio }}
      THRESH_REL: ${{ fromJSON(inputs.threshold_json).reliabilityRating }}
      THRESH_COV: ${{ fromJSON(inputs.threshold_json).unitTestCoverage }}

      POST_BUILD_DEPLOY_ENV: ${{ inputs.postBuildDeployEnv }}

    steps:
      - name: 1. (DEPURACIÓN) Mostrar contexto inicial
        run: |
          echo "--- Contexto del Workflow ---"
          echo "Repositorio (github.repository): ${{ github.repository }}"
          echo "SHA (github.sha): ${{ github.sha }}"
          echo "Workspace (github.workspace): ${{ github.workspace }}"
          echo "---------------------------------"
          echo "Listando archivos ANTES del checkout (debe estar vacío):"
          ls -la

      - name: 2. Checkout del código (del repo que llama)
        uses: actions/checkout@v4
        with:
          # ESTA ES LA LÍNEA MÁS IMPORTANTE
          # Le dice al checkout que baje el código del "Middleware"
          # y no el del "CI/CD".
          repository: ${{ github.repository }}
          
          # Le dice qué commit exacto bajar
          ref: ${{ github.sha }}
          
          # Necesario para SonarCloud
          fetch-depth: 0 
      
      - name: 3. (DEPURACIÓN) Listar archivos DESPUÉS del checkout
        run: |
          echo "---------------------------------"
          echo "Listando archivos en el workspace (debe mostrar el código del MIDDLEWARE):"
          ls -laR
          echo "---------------------------------"
          echo "Buscando 'pom.xml'..."
          # Esto nos mostrará el pom.xml que Maven usará
          find . -name "pom.xml"
          echo "---------------------------------"

      - name: 2. Configurar JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
          
      - name: 3. (Opcional) Configurar Caché de Maven
        uses: actions/cache@v4
        with:
          path: ~/.m2/repository
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-maven-

      - name: 4. Construir y Probar con Maven
        # Este paso es CRÍTICO.
        # SonarCloud necesita los archivos .class (compilados) y los reportes
        # de cobertura de pruebas (generados por 'verify') para un buen análisis.
        run: mvn -B verify --file pom.xml

      - name: 5. Ejecutar Scan de SonarCloud
        uses: SonarSource/sonarcloud-github-action@master
        env:
          # Token de GitHub (integrado) para decorar el Pull Request
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}  
          # Token de SonarCloud (que creamos en el Paso 2)
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        with:
          # (Opcional) Si tu pom.xml no está en la raíz
          # projectBaseDir: . 
          args: >
            -Dsonar.organization=poc-pipeline-conversion-jenkins-gha
            -Dsonar.projectKey=PoC-Pipeline-Conversion-Jenkins-GHA_Middleware-Java-PoC-Jenkins-a-GHA
            -Dsonar.java.binaries=target/classes
      
      - name: 2. Setup Node.js (Ejemplo)
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          
      - name: 3. Instalar dependencias (Ejemplo)
        run: npm install

      # Instala la Snyk CLI
      - name: 4. Instalar Snyk CLI
        uses: snyk/actions/setup@master

      # 5. Ejecutar Snyk Open Source (Dependencias)
      - name: 5. Run Snyk Open Source Scan
        run: |
          snyk test --sarif-file-output=snyk-oss.sarif || true
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}

      # 6. Ejecutar Snyk Code (Tu Código - SAST)
      - name: 6. Run Snyk Code Scan
        run: |
          snyk code test --sarif-file-output=snyk-code.sarif || true
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}

      # 7. Ejecutar Snyk IaC (Infraestructura como Código)
      - name: 7. Run Snyk IaC Scan
        run: |
          snyk iac test --sarif-file-output=snyk-iac.sarif || true
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}

      # 8. Subir los resultados a GitHub
      - name: 8. Upload SARIF results to GitHub
        uses: github/codeql-action/upload-sarif@v3
        with:
          # Combina todos los reportes SARIF
          sarif_file: |
            snyk-oss.sarif
            snyk-code.sarif
            snyk-iac.sarif